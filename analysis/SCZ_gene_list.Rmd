---
title: "SCZ genes list"
output: html_document
date: "2024-01-29"
---


```{r, echo=F, warning=F, message=F}
rm(list=ls())
set.seed(123)
knitr::opts_chunk$set(autodep = TRUE)
library(knitr)
library(RSQLite)
library(dplyr)
library(knitr)
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, 
                      message = FALSE, cache.lazy = FALSE) # avoid error of long vectors https://stackoverflow.com/questions/39417003/long-vectors-not-supported-yet-error-in-rmd-but-not-in-r-script 
library(kableExtra)
library(RColorBrewer)
library(gplots)
library(tidyverse)
library(gridExtra)
library(ggpubr)
library(DT)

#install_github("jdstorey/qvalue")   # install qvalue package 
library(qvalue)
#library("devtools")
#install.packages("Rtools")
#install_github('xinhe-lab/mirage')
library(mirage)

```


```{r, echo=F, message=F, warning=F}

multiplesheets <- function(fname) {
   
  # getting info about all excel sheets
  sheets <- readxl::excel_sheets(fname)
  tibble <- lapply(sheets, function(x) readxl::read_excel(fname, sheet = x))
  data_frame <- lapply(tibble, as.data.frame)
    
  # assigning names to data frames
  names(data_frame) <- sheets
    
  # print data frame
  print(data_frame)
}

pvalue_adjust=function(p_value)
{
  p_value_adjust=numeric()
for (i in 1:length(p_value))
{
  if (is.na(p_value[i])==T)
    p_value_adjust[i]=p_value[i]
  if (is.na(p_value[i])==F & p_value[i]<1e-10)
    p_value_adjust[i]="<1e-10"
  if (is.na(p_value[i])==F & p_value[i]>1e-10)
    p_value_adjust[i]=round(p_value[i],10)
}
  return(p_value_adjust)
}

```




```{r, echo=F, message=F, warning=F, results=F}
######## replicating the results 
###https://github.com/linnykos/covarianceSelection
rm(list=ls())
set.seed(123)

# install dependent packages 

#install.packages("doMC", repos="http://R-Forge.R-project.org")
library("doMC")

# if (!require("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")

#BiocManager::install("org.Hs.eg.db")
library("org.Hs.eg.db")

#download gz file to local folder and install https://cran.r-project.org/src/contrib/Archive/dequer/
library(dequer)


library("devtools")
devtools::install_github("linnylin92/covarianceSelection", subdir = "covarianceSelection")

```




```{r, echo=F, message=F, warning=F, eval=F}
# step0_loading.R  https://github.com/linnykos/covarianceSelection/blob/master/main/step0_loading.R
# step0_loading.R loads the BrainSpan dataset and TADA dataset (i.e., matching the genes in both datasets, resolving gene synonyms, removing genes not expressed in the brain).

#if(verbose) print("Start of step 0: Loading")

#format the brainspan dataset
#load("../../raw_data/newGenexp.RData")
load("C:/han/Dataset/20231006_PMID_33731968/NIHMS1598069-supplement-Supp_1/newGenexp.RData")
rownames(genexp) <- genexp[,1]
genexp <- genexp[,-1]
genexp <- t(genexp)
genexp <- as.data.frame(genexp) # 1340 x 16947 ? what does row names indicate? 

#determine brain-expressed genes
brain_expression <- covarianceSelection::brain_expression # how these genes are known to be expressed genes????????  
brain_genes <- brain_expression$Gene[brain_expression$Brain_expressed != 'No']
idx <- which(colnames(genexp) %in% brain_genes)
genexp <- genexp[,idx] # 1340 x 14370

############ sample information is in covarianceSelection::brainspan_id


#translate into synonyms
vec <- covarianceSelection::symbol_synonyms(colnames(genexp), verbose = T)
unknown_genes_idx <- which(is.na(vec))
vec <- vec[-unknown_genes_idx]
genexp <- genexp[-unknown_genes_idx] # 1340 x 14297
colnames(genexp) <- vec

#average non-unique genes
genexp <- covarianceSelection:::average_same_columns(genexp) # 1340 x 14246

#remove samples from subregions that we don't have a region for
region_subregion <- covarianceSelection::region_subregion
vec <- rownames(genexp)
subregion <- unlist(strsplit(vec,"\\."))[seq(2, length(vec)*4, 4)]
idx <- which(subregion %in% region_subregion$subregion)
genexp <- genexp[idx,] # 1294 x 14249

################
# explore the notations in row names 
#sample_names=rownames(genexp)
#comma_position=gregexpr(".", sample_names[1])
#sample_names[grepl("VFC",sample_names)] # find samples having "VFC"
################

####

#load tada dataset
#tada <- covarianceSelection::tada

# load SCZ gene 
SCHEMA_gene_results=multiplesheets("C:\\han\\Dataset\\SCHEMA\\41586_2022_4556_MOESM3_ESM.xlsx")
scz1=data.frame(Gene=SCHEMA_gene_results$`Table S5 - Gene Results`$`Gene Symbol`, pval.meta=SCHEMA_gene_results$`Table S5 - Gene Results`$`P meta`, qval.meta=SCHEMA_gene_results$`Table S5 - Gene Results`$`Q meta`, dn_PTV=SCHEMA_gene_results$`Table S5 - Gene Results`$`De novo PTV`) 
scz1$dn_PTV[is.na(scz1$dn_PTV)]=0   # fill missing PTV with 0 
scz1=scz1%>% drop_na()  # remove NA's  ######## this is important 
#scz1=scz1%>% mutate(qval.meta=qvalue(scz1$pval.meta)$qvalues)
# add one colum of q values of SCZ as in tada????????

scz=scz1[-c(9934,  9935,  9936, 13100),]   #  remove duplicates which(duplicated(scz1$Gene)==T)
#unique_gene= unique(scz1$Gene)
#scz=data.frame(Gene=unique_gene, pval.meta=scz1$pval.meta[which(scz1$Gene %in% unique_gene)])  # remove duplicates 

#match the order in both datasets
#idx <- which(colnames(genexp) %in% tada$Gene)
idx <- which(colnames(genexp) %in% scz$Gene)
genexp <- genexp[,idx] # 1294 x 13964
#idx <- which(tada$Gene %in% colnames(genexp))
idx <- which(scz$Gene %in% colnames(genexp))
#tada <- tada[idx,] # 13964 genes
scz=scz[idx,]
#idx <- covarianceSelection::matching(tada$Gene, colnames(genexp))
idx <- covarianceSelection::matching(scz$Gene, colnames(genexp))
genexp <- genexp[,idx]

dat_list <- covarianceSelection::extractor(genexp) # 212 partitions
dat_list <- lapply(dat_list, as.matrix, drop = F)

# remove partitions too small
idx <- which(sapply(dat_list, function(x){ifelse(nrow(x) >= 5, T, F)}))
dat_list <- dat_list[idx] # 125 partitions
dat_list <- lapply(dat_list, scale, scale = F)

#if(verbose) print(paste0("Dimension of genexp is: ", paste0(dim(genexp), collapse = ", ")))

#cleanup
rm(list = c("brain_expression", "brain_genes", "idx", "vec", "region_subregion",
            "subregion", "genexp", "unknown_genes_idx"))

#save.image(file = paste0(save_filepath, "/step0_loading", filepath_suffix, ".RData"))

```




```{r, echo=F, message=F, warning=F, eval=F}
# step1_screening.R screens the genes according to Liu et al. (2015). This is reported in Section 6.1.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step1_screening.R
p_thres_screening <- 0.01 
p_primary <- 0.1
num_genes <- 3500
verbose=T

###

if(verbose) print(paste0(Sys.time(), "Start of step 1: Screening"))

selected_idx <- grep("PFC\\.[3-5]", names(dat_list))
dat_pfc35 <- do.call(rbind, dat_list[selected_idx]) # 107 x 13964  --> 107 x 12879  

#screening_res <- covarianceSelection::screen(dat_pfc35, pv = tada$pval.TADA, p_thres = p_thres_screening, 
#                                             num_genes = num_genes)

screening_res <- covarianceSelection::screen(dat_pfc35, pv = scz$pval.meta, p_thres = p_thres_screening, 
                                             num_genes = num_genes)

# 193 primary, 3307 secondary, total of 3500

# reorder which genes are primary and which are secondary
all_idx <- sort(unique(c(screening_res$primary, screening_res$secondary)))
#screening_res$primary <- all_idx[which(tada$pval.TADA[all_idx] < p_primary)]
screening_res$primary <- all_idx[which(scz$pval.meta[all_idx] < p_primary)]
screening_res$secondary <- setdiff(all_idx, screening_res$primary)

# apply the new gene list
for(i in 1:length(dat_list)){
  dat_list[[i]] <- dat_list[[i]][,c(screening_res$primary, screening_res$secondary)]
}
#tada <- tada[c(screening_res$primary, screening_res$secondary),]
 scz=scz[c(screening_res$primary, screening_res$secondary),]
                
if(verbose) print(paste0("Dimension of dat_list is: ", unique(sapply(dat_list, ncol)), collapse = ", "))

#rm(list = c("selected_idx", "dat_pfc35", "i"))

#save.image(file = paste0(save_filepath, "/step1_screening", filepath_suffix, ".RData"))
```



```{r, echo=F, message=F, warning=F, eval=F}
# https://github.com/linnykos/covarianceSelection/blob/master/main/step2_nodawn_analysis.R
# step2_nodawn_analysis.R detects the risk genes only based on the TADA dataset.

fdr_cutoff_alt <- 0.05
verbose=T

if(verbose) print(paste0(Sys.time(), "Start of step 2: No DAWN analysis"))

#genes_nodawn <- sort(as.character(tada[which(tada$qvalue <= fdr_cutoff_alt),"Gene"]))
genes_nodawn <- sort(as.character(scz[which(scz$qval.meta <= fdr_cutoff_alt),"Gene"]))

#save.image(file = paste0(save_filepath, "/step2_nodawn_analysis", filepath_suffix, ".RData"))
```


```{r echo=F, message=F, warning=F, eval=F}
# step3_pfc35_analysis.R implicates risk genes in the DAWN framework using the Window 1B partitions. This is reported in Section 6.4.
# https://github.com/linnykos/covarianceSelection/blob/master/main/step3_pfc35_analysis.R
fdr_cutoff <- 0.01
pthres <- 0.05
verbose=T

#####
set.seed(10)
if(verbose) print(paste0(Sys.time(), "Start of step 3: Naive analysis"))

selected_idx <- grep("PFC\\.[3-5]", names(dat_list))
dat_pfc35 <- do.call(rbind, dat_list[selected_idx]) # 107 x 3065
dat_pfc35 <- scale(dat_pfc35, scale = F)

# estimate graphical model on PFC35 using cross-validated lasso for neighborhood selection
# res <- covarianceSelection::graphicalModel_range(dat_pfc35, 1:length(screening_res$primary), 
#                                                  lambda_min = 0.01, lambda_max = 0.35, 
#                                                  lambda_length = 30, verbose = T) 
# save.image(file = paste0(save_filepath, "/step3_pfc35_analysis", filepath_suffix, ".RData"))
# 
# scale_vec_pfc35 <- sapply(res, function(x){covarianceSelection::compute_scale_free(as.matrix(x$adj_mat))})
# edges_vec_pfc35 <- sapply(res, function(x){sum(as.matrix(x$adj_mat))/2})
# # idx <- which.max(scale_vec_pfc35)
# idx <- 27
# adj_pfc35 <- as.matrix(res[[idx]]$adj_mat)

res <- covarianceSelection::graphicalModel(dat_pfc35, primary_idx = 1:length(screening_res$primary), lambda = seq(0.05, 0.1, length.out = 15)[1])
adj_pfc35 <- as.matrix(res$adj_mat)
#stopifnot(all(dim(adj_pfc35) == nrow(tada)))
stopifnot(all(dim(adj_pfc35) == nrow(scz)))

# run the HMRF
set.seed(10)
seedindex <- rep(0, ncol(adj_pfc35))
#seedindex[which(tada$dn.LoF >= 3)] <- 1  ### seedindex: a (0,1) vector of length d, where 1 means the gene is in group 1
seedindex[which(scz$dn_PTV >= 1)] <- 1

if(verbose) print(paste0(Sys.time(), ": HMRF"))
set.seed(10)
#hmrf_pfc35 <- covarianceSelection::hmrf(tada$pval.TADA, adj_pfc35, seedindex, pthres = pthres)
#report_pfc35 <- covarianceSelection::report_results(tada$Gene, 1-hmrf_pfc35$post, tada$pval.TADA, hmrf_pfc35$Iupdate)
#genes_pfc35 <- sort(as.character(report_pfc35$Gene[which(report_pfc35$FDR <= fdr_cutoff)]))

hmrf_pfc35 <- covarianceSelection::hmrf(scz$pval.meta, adj_pfc35, seedindex, pthres = pthres)

report_pfc35 <- covarianceSelection::report_results(scz$Gene, 1-hmrf_pfc35$post, scz$pval.meta, hmrf_pfc35$Iupdate)
genes_pfc35 <- sort(as.character(report_pfc35$Gene[which(report_pfc35$FDR <= fdr_cutoff)]))

adj_pfc35 <- Matrix::Matrix(adj_pfc35, sparse = T)

#rm(list = c("dat_pfc35", "seedindex", "idx", "res", "selected_idx"))

#save.image(file = paste0(save_filepath, "/step3_pfc35_analysis", filepath_suffix, ".RData"))

########################

 #plot(exp(seq(log(0.01), log(0.35), length.out = length(scale_vec_pfc35))), scale_vec_pfc35)
```




